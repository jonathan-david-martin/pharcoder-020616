/**
 * Player.js
 *
 * Base class representing a user interacting with the game world
 */
'use strict';

/**
 * Represents a player, both long term and session properties
 *
 * @param {string} gamertag - In game handle
 * @param {string} password - Cleartext password
 * @param {Regime} regimeId - Regime to which player belongs
 * @param {string} role - Role for player
 * @param {object} demographics - Extended identity info
 * @constructor
 */
var Player = function (gamertag, password, regimeId, role, demographics) {
    this.init();
    this.id = null;
    this.gamertag = gamertag;
    this.password = password;
    this.passwordClear = true;
    this.role = role;
    this.regimeId = regimeId;
    if (demographics) {
        this.demographics = demographics;       // FIXME: Probably want to destructure
    }
};

/**
 * Constructor type for DB object mapping
 * @type {string}
 */
Player.prototype.cType = 'Player';

/**
 * Set up internal data for new player
 */
Player.prototype.init = function () {
    this.instancetype = 'player';       // Debugging
    /**
     * Flag for just added players so they get full updates
     * @type {boolean}
     */
    this.newborn = true;

    /**
     * Socket.io connection to client
     * @type {io.Socket}
     */
    this.socket = null;

    /**
     * Ship object for logged in player
     * @type {Ship}
     */
    this.ship = null;

    /**
     * Role determines kind / level of access to game functions
     * @type {string}
     */
    this.role = 'player';

    /**
     * Per session game stats
     * @namespace
     * @property {Object} stats
     * @property {number} stats.tags
     * @property {number} stats.treesPlanted
     * @property {number} stats.bestTagStreak
     * @property {number} stats.currentTagStreak
     */
    this.stats = {
        tags: 0,
        treesPlanted: 0,
        bestTagStreak: 0,
        currentTagStreak: 0
    };

    /**
     * Saved code
     * @type {object}
     */
    this.codeSnippets = {};

    /**
     * Code to be executed by interpreter
     * @type {Array}
     */
    this.codeQueue = [];

    /**
     * Events to be executed by interpreter, generated by code and/or player actions
     * @type {Array}
     */
    this.eventQueue = [];

    /**
     * Currently running sandbox interpreter, if any
     * @type {Interpreter} interpreter
     */
    this.interpreter = null;

    /**
     * Currently active tutorial, if any
     * @type {FSM}
     */
    this.tutorial = null;

    /**
     * Defined as property to make non-enumerable
     * @type {number}
     */
    Object.defineProperty(this, 'cacheTimeout', {writable: true});
};

/**
 * Initialize player from database
 * @param {object} record
 * @param {string} record._id - database id
 * @param {string} record.name - Real name of player
 * @param {string} record.gamertag - In game handle for player
 * @param {string} record.role - Role determining level of access to game
 */
Player.prototype.restore = function (record) {
    //console.log('P restore', record);
    this.id = record._id.toHexString();
    this.gamertag = record.gamertag || record.username; // backwards compatibility
    this.password = record.password;
    this.codeSnippets = record.codeSnippets;
};

/**
 * Return a representation suitable for saving to database
 *
 * @returns {object}
 */
Player.prototype.save = function () {
    var o = {
        username: this.gamertag,
        password: this.password,
        codeSnippets: this.codeSnippets,
        regimeId: this.regimeId
    };
    if (this.id) {
        o._id = this.id;
    }
    return o;
};

/**
 * Return object to send to client - Stopgap implementation
 * @returns {object}
 */
Player.prototype.getPOJO = function () {
    return {id: this.id, username: this.gamertag};
};

Player.prototype.sendMessage = function (type, detail) {
    this.socket.emit('msg ' + type, detail);
};

/* *Ship methods temp until can fix implementation elsewhere */

Player.prototype.addShip = function (ship) {
    this.ship = ship;
};

Player.prototype.getShip = function (w) {
    return this.ship;
};

/**
 * Mark task accomplished and advance tutorial as necessary
 * @param {string} task - Identifier of task accomplished
 */
Player.prototype.accomplish = function (task) {
    if (this.tutorial) {
        this.tutorial.transition(task);
    }
};
Player.prototype.achieve = Player.prototype.accomplish;     // FIXME

Player.playerTypes = {};
Player.playerTypes['Player'] = Player;

module.exports = Player;
